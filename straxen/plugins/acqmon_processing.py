import strax
import straxen
import numba
import numpy as np
from immutabledict import immutabledict

export, __all__ = strax.exporter()

# More info about the acquisition monitor can be found here:
# https://xe1t-wiki.lngs.infn.it/doku.php?id=xenon:xenon1t:alexelykov:acquisition_monitor

@export
@strax.takes_config(strax.Option('hit_min_amplitude_aqmon', default = 50, track = False,
                                 help = 'Minimum hit threshold in ADC*counts above baseline'))

class AcqmonHits(strax.Plugin):
    """ Find hits in acquisition monitor data. These hits could be 
        then used by other plugins for deadtime calculations, 
        GPS SYNC analysis, etc.
    """
    __version__ ='0.0.2'
    
    depends_on = ('raw_records_aqmon') 
    provides  = ('acqmon_hits')
    data_kind = ('acqmon_hits')
    
    dtype = strax.hit_dtype
    
    def compute(self, raw_records_aqmon):
        rec = strax.raw_to_records(raw_records_aqmon)
        strax.zero_out_of_bounds(rec)
        strax.baseline(rec, baseline_samples = 10, flip = True)
        acqmon_hits = strax.find_hits(rec, min_amplitude = self.config['hit_min_amplitude_aqmon'])
    
        return acqmon_hits 

    

#### Veto hardware ####:
# V1495 busy veto module: 
# Generates a 25 ns NIM pulse whenever a veto begins and a 25 ns NIM signal when it ends. 
# A new start signal can occur only after the previous busy instance ended.
# 1ms (1e6 ns) - minimum busy veto length, or until the board clears its memory
    
# DDC10 High Energy Veto:
# 10ms (1e7 ns) - fixed HE veto length in XENON1T DDC10, 
# in XENONnT it will be calibrated based length of large S2 SE tails
# The start/stop signals for the HEV are generated by the V1495 board
  
@export
@strax.takes_config(
    strax.Option('max_veto_gap', default = int(5e8),
                 help = 'Maximum separation between veto stop and start pulses [ns]'),
    strax.Option('channel_map', track = False, type = immutabledict, 
                 help = 'immutabledict mapping subdetector to (min, max)'
                      'channel number.'))

class VetoIntervals(strax.OverlapWindowPlugin):
    """ Find pairs of veto start and veto stop signals and the veto duration between them
    busy_*  <= V1495 busy veto for tpc channels
    he_*    <= V1495 busy veto for high energy tpc channels
    hev_*   <= DDC10 hardware high energy veto
    """
        
    __version__ ='0.0.22'
    depends_on = ('acqmon_hits') 
    provides  = ('veto_intervals')
    data_kind = ('veto_intervals')


    aqmon_channel_names = ('sum_wf','m_veto_sync',
                           'hev_stop', 'hev_start', 
                           'he_stop','he_start',
                           'busy_stop', 'busy_start')
    
    tmp_dtype = strax.time_fields

    def infer_dtype(self):
        dtype = [(('veto start time since unix epoch [ns]', 'time'), np.int64)]
        dtype += [(('veto end time since unix epoch [ns]', 'endtime'), np.int64)]
        dtype += [(('veto interval [ns]', 'veto_interval'), np.int64)]
        dtype += [(('veto signal type', 'veto_type'), np.str('U10'))]
        return dtype
    
    def setup(self):
        # Keeping ch_numbers and ch_range as class attributes for now, maybe will need them for other features
        self.channel_numbers = np.arange(800,808, 1)
        self.channel_range = self.config['channel_map']['aqmon']
        self.channel_map = dict(zip(self.aqmon_channel_names, self.channel_numbers))
        self.veto_names = ['busy_','he_','hev_']
        return self.channel_map
    
    def get_window_size(self):
        # Give a very wide window
        return (self.config['max_veto_gap']*100)
    
    def compute(self, acqmon_hits): 
        hits = acqmon_hits
        
        res = dict()
        for i, veto in enumerate(self.veto_names):
            channels = channel_select(hits, self.channel_map[veto + 'stop'], self.channel_map[veto + 'start'])
            vetos = self.merge_vetos(channels, gap = self.config['max_veto_gap'],\
                                           dtype = self.tmp_dtype, t = 0)
            
            # Check that we found a veto start time and then populate the resulting dict
            if np.any(vetos['time']):
                res['time'] = vetos['time']
                res['endtime'] = vetos['endtime']
                res['veto_interval'] = vetos['endtime'] - vetos['time']
                res['veto_type'] = veto + 'veto'        
        return res
    
    @staticmethod
    def merge_vetos(channels, gap, dtype, t):
        if len(channels):
            start, stop = strax.find_peak_groups(channels, gap_threshold = gap)
            result = np.zeros(len(start),dtype=dtype)
            result['time'] = start 
            result['endtime'] = stop
        else:
            result = np.zeros(1,dtype=dtype)
            result['time'] =  t
            result['endtime'] = t
        return result
            
@numba.njit
def _mask(x, mask):
    return x[mask]

@export
@numba.njit
def channel_select(rr, ch_stop, ch_start):
    """Return data in between stop and start channels of the acquisition monitor (AM). 
       The order is reversed becasue physical inputs on the AM board go as stop -> start
       for all the veto signals i.e. 806 = busy_stop and 807 = busy_start """
    return _mask(rr, (rr['channel'] >= ch_stop) & (rr['channel'] <= ch_start)) 

